#!/usr/bin/env node

const { resolve, basename } = require('path')
const { warn, error } = require('ara-console')
const inquirer = require('inquirer')
const { DID } = require('did-uri')
const program = require('yargs')
const crypto = require('ara-crypto')
const debug = require('debug')('ara:network:keys')
const keys = require('../keys')
const pify = require('pify')
const rc = require('../rc')()
const ss = require('ara-secret-storage')
const fs = require('fs')

const $0 = basename(process.argv[1] || 'ara-network-keys')

process.on('unhandledRejection', onfatal)
process.on('uncaughtException', onfatal)

const { argv } = program
  .wrap(100)
  .alias('help', 'h')
  .alias('version', 'V')
  .usage('usage: $0 [-hDV] [options] [did]')
  .option('D', {
    type: 'boolean',
    alias: 'debug',
    describe: 'Enable debug output'
  })
  .option('i', {
    type: 'string',
    alias: 'identity',
    default: rc.network.identity.whoami,
    describe: 'ARA Identity DID URI',
    required: true,
  })
  .option('s', {
    type: 'string',
    alias: 'secret',
    describe: 'Shared secret key value or file path',
    required: true
  })
  .option('n', {
    type: 'string',
    alias: 'network',
    describe: 'Human readable network name for keys generated',
  })
  .option('o', {
    type: 'string',
    alias: 'out',
    describe: 'Output file name',
    default: rc.network.identity.keyring,
    required: true,
  })
  .option('p', {
    type: 'boolean',
    alias: 'personal',
    describe: 'Generate personal network keys for given identity'
  })

// eslint-disable-next-line
void async function main() {
  process.title = $0

  if (program.argv.debug) {
    /* eslint-disable-next-line global-require */
    require('debug').enable('ara:network*')
  }

  if (!argv.secret) {
    return onfatal(new Error('Missing shared secret'))
  }

  if (argv.name && 'string' === typeof argv.name && !argv.network) {
    warn('Please use \'--network\' instead of \'--name\'.')
    // eslint-disable-next-line no-param-reassign
    argv.network = argv.name
  }

  if (!argv.personal && !argv.network) {
    return onfatal(new Error('Network name required for non-personal keyrings'))
  }

  let publicKey = null
  let secretKey = null
  let secret = null
  let buffer = null

  try {
    const stat = await pify(fs.stat)(argv.secret)
    if (stat.isFile()) {
      secret = await pify(fs.readFile)(argv.secret)
    }
  } catch (err) {
    void err
  }

  let { password } = await inquirer.prompt([ {
    type: 'password',
    name: 'password',
    message:
    'Please enter the passphrase associated with the signing identity.\n' +
    'Passphrase:'
  } ])

  if (argv.identity && 0 !== argv.identity.indexOf('did:ara:')) {
    argv.identity = `did:ara:${argv.identity}`
  }

  const did = new DID(argv.identity)

  secret = Buffer.from(argv.secret)
  password = crypto.blake2b(Buffer.from(password))
  publicKey = Buffer.from(did.identifier, 'hex')

  // @TODO(jwerle): this should a function of AID
  const hash = crypto.blake2b(publicKey).toString('hex')
  const path = resolve(rc.network.identity.root, hash, 'keystore/ara')
  const keystore = JSON.parse(await pify(fs.readFile)(path, 'utf8'))

  try {
    secretKey = ss.decrypt(keystore, { key: password.slice(0, 16) })
  } catch (err) {
    debug(err)
    return onfatal(new Error('Invalid passphrase'))
  }

  argv.out = resolve(argv.out)

  try {
    if (argv.personal) {
      buffer = keys.generate({ secret, publicKey, secretKey })
    } else {
      const keyPair = keys.derive({
        secretKey, name: argv.network
      })

      buffer = keys.generate({
        secret,
        publicKey: keyPair.publicKey,
        secretKey: keyPair.secretKey
      })
    }
  } catch (err) {
    onfatal(err)
  }

  try {
    const secretKeyring = keys.keyRing(argv.out, { secret: secretKey })
    const publicKeyring = keys.keyRing(`${argv.out}.pub`, { secret })

    if (argv.personal) {
      if (false === await publicKeyring.has(publicKey)) {
        await publicKeyring.append(publicKey, buffer.slice(0, keys.PK_SIZE))
      } else {
        warn('Public personal keys already exists in public key ring')
      }

      if (false === await secretKeyring.has(secretKey)) {
        await secretKeyring.append(secretKey, buffer.slice(0, keys.PK_SIZE))
      } else {
        warn('Secret personal keys already exists in secret key ring')
      }
    } else {
      if (false === await publicKeyring.has(argv.network)) {
        await publicKeyring.append(argv.network, buffer.slice(0, keys.PK_SIZE))
      } else {
        warn(`'${argv.network}' already exists in public key ring`)
      }

      if (false === await secretKeyring.has(argv.network)) {
        await secretKeyring.append(argv.network, buffer.slice(keys.PK_SIZE))
      } else {
        warn(`'${argv.network}' already exists in secret key ring`)
      }
    }
  } catch (err) {
    onfatal(err)
  }
}()

function onfatal(err) {
  error('fatal:', err.message)
  debug(err.stack)
  process.exit(1)
}
