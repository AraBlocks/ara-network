#!/usr/bin/env node

const { resolve, basename } = require('path')
const { warn, error } = require('ara-console')
const inquirer = require('inquirer')
const { DID } = require('did-uri')
const program = require('yargs')
const crypto = require('ara-crypto')
const debug = require('debug')('ara:network:keys')
const keys = require('../keys')
const pify = require('pify')
const rc = require('../rc')(require('ara-identity/rc')())
const fs = require('fs')

const $0 = basename(process.argv[1] || 'ara-network-keys')

process.on('unhandledRejection', onfatal)
process.on('uncaughtException', onfatal)

const { argv } = program
  .wrap(100)
  .alias('help', 'h')
  .alias('version', 'V')
  .usage('usage: $0 [-hDV] [options] [did]')
  .option('debug', {
    type: 'boolean',
    alias: 'D',
    describe: 'Enable debug output'
  })
  .option('identity', {
    type: 'string',
    alias: 'i',
    describe: 'ARA Identity DID URI',
    required: true
  })
  .option('secret', {
    type: 'string',
    alias: 's',
    describe: 'Shared secret key value or file path',
    required: true
  })
  .option('name', {
    type: 'string',
    alias: 'n',
    describe: 'Human readable name for network keys',
    required: true
  })
  .option('out', {
    type: 'string',
    alias: 'o',
    describe: 'Output file name',
    required: true,
  })

// eslint-disable-next-line
void async function main() {
  process.title = $0

  if (program.argv.debug) {
    /* eslint-disable-next-line global-require */
    require('debug').enable('ara:network*')
  }

  if (!argv.secret) {
    return onfatal(new Error('Missing shared secret'))
  }

  let publicKey = null
  let secretKey = null
  let secret = Buffer.from(argv.secret)

  try {
    const stat = await pify(fs.stat)(argv.secret)
    if (stat.isFile()) {
      secret = await pify(fs.readFile)(argv.secret)
    }
  } catch (err) {
    void err
  }

  let { password } = await inquirer.prompt([ {
    type: 'password',
    name: 'password',
    message:
    'Please enter the passphrase associated with the signing identity.\n' +
    'Passphrase:'
  } ])

  if (argv.identity && 0 !== argv.identity.indexOf('did:ara:')) {
    argv.identity = `did:ara:${argv.identity}`
  }

  const did = new DID(argv.identity)

  password = crypto.blake2b(Buffer.from(password))
  publicKey = Buffer.from(did.identifier, 'hex')

  // @TODO(jwerle): this should a function of AID
  const hash = crypto.blake2b(publicKey).toString('hex')
  const path = resolve(rc.network.identity.root, hash, 'keystore/ara')
  const keystore = JSON.parse(await pify(fs.readFile)(path, 'utf8'))

  try {
    secretKey = crypto.decrypt(keystore, { key: password.slice(0, 16) })
  } catch (err) {
    return onfatal(new Error('Invalid passphrase'))
  }

  argv.out = resolve(argv.out)

  const buffer = keys.generate({ secret, publicKey, secretKey })

  const secretKeyring = keys.keyRing(argv.out, { secret: secretKey })
  const publicKeyring = keys.keyRing(`${argv.out}.pub`, { secret })

  if (false === await publicKeyring.has(argv.name)) {
    await publicKeyring.append(argv.name, buffer.slice(0, keys.PK_SIZE))
  } else {
    warn('\'%s\' already exists in public key ring', argv.name)
  }

  if (false === await secretKeyring.has(argv.name)) {
    await secretKeyring.append(argv.name, buffer.slice(keys.PK_SIZE))
  } else {
    warn('\'%s\' already exists in secret key ring', argv.name)
  }
}()

function onfatal(err) {
  error('fatal:', err.message)
  debug(err.stack)
  process.exit(1)
}
