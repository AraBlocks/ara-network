#!/usr/bin/env node

const { error, info } = require('ara-console')
const { createKey } = require('../createKey')
const { basename } = require('path')
const inquirer = require('inquirer')
const program = require('yargs')
const debug = require('debug')('ara:network:keys')
const rc = require('../rc')()

const $0 = basename(process.argv[1] || 'ara-network-keys')

process.on('unhandledRejection', onfatal)
process.on('uncaughtException', onfatal)

const { argv } = program
  .wrap(100)
  .alias('help', 'h')
  .alias('version', 'V')
  .usage('usage: $0 [-hDV] [options] [did]')
  .option('D', {
    type: 'boolean',
    alias: 'debug',
    describe: 'Enable debug output'
  })
  .option('i', {
    type: 'string',
    alias: 'identity',
    default: rc.network.identity.whoami,
    describe: 'ARA Identity DID URI',
    required: true,
  })
  .option('s', {
    type: 'string',
    alias: 'secret',
    describe: 'Shared secret key value or file path',
    required: true
  })
  .option('n', {
    type: 'string',
    alias: 'name',
    describe: 'Human readable name for network keys',
  })
  .option('o', {
    type: 'string',
    alias: 'out',
    describe: 'Output file name',
    default: rc.network.identity.keyring,
    required: true,
  })
  .option('p', {
    type: 'boolean',
    alias: 'personal',
    describe: 'Generate personal network keys for given identity'
  })

// eslint-disable-next-line
void async function main() {
  process.title = $0

  if (argv.debug) {
    /* eslint-disable-next-line global-require */
    require('debug').enable('ara:network*')
  }

  if (!argv.personal && !argv.name) {
    return onfatal(new Error('Name required for non-personal keyrings'))
  }

  let { password } = await inquirer.prompt([ {
    type: 'password',
    name: 'password',
    message:
    'Please enter the passphrase associated with the signing identity.\n' +
    'Passphrase:'
  } ])

  try {
    await createKey(Object.assign({}, argv, { password }))
    info(`\`${argv.name}\` created successfully in ${argv.out} keyring`)
    return process.exit(0)
  } catch (e) {
    onfatal(e)
  }
}()

function onfatal(err) {
  error('fatal:', err.message)
  debug(err.stack)
  process.exit(1)
}
