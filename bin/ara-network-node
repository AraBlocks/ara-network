#!/usr/bin/env node

const { info, warn, error } = require('ara-console')
const { basename, resolve } = require('path')
const onBeforeExit = require('async-exit-hook')
const cluster = require('cluster')
const package = require('../package')
const program = require('yargs')
const debug = require('debug')('ara:network:node')
const rc = require('ara-runtime-configuration')()

const $0 = basename(process.argv[1] || `${package.name}-node`)

module.exports = { main, boot, program }

void program
  .help(false)
  .version(false)
  .alias('help', 'h')
  .alias('version', 'V')
  .option('conf', {
    type: 'string',
    alias: 'C',
    describe: "Path to configuration file"
  })
  .option('debug', {
    type: 'boolean',
    alias: 'D',
    describe: "Enable debug output"
  })

// from command line
if (null == module.parent) {
  process.on('unhandledRejection', onfatal)
  process.on('uncaughtException', onfatal)
  main()
}

/**
 * Main program entry
 * @public
 */
async function main() {
  const { t, type = t } = program.argv
  const { V, version = V } = program.argv

  process.title = $0

  if (version) {
    info("%s version: %s", package.name, package.version)
    process.exit(0)
  }

  if (null == type) {
    help()
    if (program.argv.help) {
      program.showHelp()
      return process.exit(0)
    } else if (process.argv.length <= 2) {
      program.showHelp()
      return process.exit(1)
    }
  }

  if (program.argv.debug) {
    require('debug').enable('ara:network*')
  }

  if (false == cluster.isMaster) {
    process.on('message', onmessage)
  } else {
    if (type && false == Array.isArray(type)) {
      await boot({type})
    } else {
      void warn(
        "Multiple network node types given. Ignoring other arguments."
      )

      for (const k of type) {
        await boot({type: k})
      }
    }
  }
}

/**
 * Fork process and boot worker node.
 * @public
 * @param {Object} opts
 * @param {Object} opts.type
 * @return {cluster.Worker}
 */
async function boot({type}) {
  const worker = cluster.fork()
  const { id } = worker
  worker.send({id, type})
  worker.on('error', onerror)
  return worker
  function onerror(err) {
    error("worker#%s: %s: error:", id, type, err.message)
  }
}

/**
 * Configures program usage
 */
function help() {
  program
    .help(true)
    .version(true)
    .usage('usage: $0 [-hV] [options]')
    .option('type', {
      type: 'string',
      alias: 't',
      describe: "Node type to start"
    })
}

/**
 * Worker message callback
 * @private
 * @param {Object} event
 */
async function onmessage({id, type}) {
  let node = null
  const boot = (paths) =>  {
    try { node = require(paths.shift()) }
    catch (err) {
      debug(err)
      if (paths.length) { return boot(paths) } else {
        error("worker: %s: Unknown node type: %s", type, err.message)
        return process.exit(1)
      }
    }
  }

  boot([
    `../nodes/${type}`,
    `ara-network-node-${type}`,
    type,
    resolve(type)
  ])

  if (null == node) {
    error("Unable to resolve node type '%s'.", type)
    return process.exit(1)
  }

  const {
    getInstance,
    configure,
    start,
    stop,
  } = node

  if ('function' != typeof start) {
    error("Node type '%s' is not startable (Missing 'start' function)", type)
    return process.exit(1)
  }

  if ('function' != typeof stop) {
    error("Node type '%s' is not stopable (Missing 'stop' function)", type)
    return process.exit(1)
  }

  const multipleTypesGiven = (
    Array.isArray(program.argv.type) ||
    Array.isArray(program.argv.t))

  if ('function' == typeof configure) {
    const conf = {}
    if (rc.network && rc.network.node && 'object' == typeof rc.network.node[type]) {
      Object.assign(conf, rc.network.node[type])
    }
    program.usage(`usage: $0 -t ${type} [options]`).help(true)
    const promise = configure(conf, program)
    void program.argv // parse
    info("Configuring network node '%s'.", type)
    await promise
  }

  const argv = multipleTypesGiven ? {} : program.argv

  try {
    info("Starting network node '%s'", type)
    if (true !== await start(argv)) {
      onfatal(new Error(`Failed to start network node '${type}'`))
    }
  } catch (err) {
    debug(err)
    error("fatal: Network node '%s' encountered an error: ", err.message)
    return process.exit(1)
  }

  process.title += ` (${type})`

  const instance = await getInstance(argv)
  instance.on('error', onerror)
  onBeforeExit(onexit)

  function onerror(err) {
    error("worker#%s: %s: error:", id, type, err.message)
  }

  async function onexit(done) {
    warn("Stopping network node '%s'", type)
    await stop(argv)
    done()
  }
}

/**
 * Handles fatal errors.
 * @private
 * @param {Error} err
 */
function onfatal(err) {
  debug(err)
  error("fatal:", err.message)
  process.exit(1)
}
