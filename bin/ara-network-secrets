#!/usr/bin/env node

const { info, warn, error } = require('ara-console')
const { resolve, basename } = require('path')
const collect = require('collect-stream')
const program = require('yargs')
const secrets = require('../secrets')
const crypto = require('ara-crypto')
const mkdirp = require('mkdirp')
const debug = require('debug')('ara:network:secrets')
const pify = require('pify')
const get = require('get-uri')
const url = require('url')
const rc = require('../rc')()
const fs = require('fs')

const $0 = basename(process.argv[1] || 'ara-network-secrets')

const { argv } = program
  .wrap(100)
  .alias('help', 'h')
  .alias('version', 'V')
  .usage("usage: $0 [-hV] [options] [secrets]")
  .option('debug', {
    type: 'boolean',
    alias: 'D',
    describe: "Enable debug output"
  })
  .option('import', {
    type: 'boolean',
    alias: 'i',
    describe: "Import keystore into network"
  })
  .option('export', {
    type: 'boolean',
    alias: 'e',
    describe: "Export keystore from network"
  })
  .option('public', {
    type: 'boolean',
    alias: 'p',
    describe: "Export public secrets"
  })
  .option('key', {
    type: 'string',
    alias: 'k',
    describe: "Encyrption key for keystore",
  })
  .option('seed', {
    type: 'string',
    alias: 's',
    describe: "Secrets seed value",
    optional: true,
  })
  .option('out', {
    type: 'string',
    alias: 'o',
    describe: "Output directory",
  })
  .option('root', {
    type: 'string',
    describe: "Root data directory",
    default: rc.network.secrets.root
  })

process.on('unhandledRejection', onfatal)
process.on('uncaughtException', onfatal)

void async function main() {
  const keys = {}
  process.title = $0

  if (program.argv.debug) {
    require('debug').enable('ara:network*')
  }

  if (argv.root) {
    try { await pify(fs.access)(argv.root) }
    catch (err) {
      warn("mkdirp: Making network secrets root directory:", argv.root)
      try { await pify(mkdirp)(argv.root) }
      catch (err) { return onfatal(err) }
    }

    const stat = await pify(fs.stat)(argv.root)

    if (false == stat.isDirectory()) {
      return onfatal(new TypeError(`Not a directory: ${argv.root}`))
    }
  }

  if (argv.import) {
    if (null == argv.key) {
      throw new TypeError("Expecting network key for secrets.")
    }

    for (let filename of argv._) {
      let { protocol } = url.parse(filename)
      if (null == protocol) {
        filename = resolve(filename)
        filename = 'file://'+ filename
        protocol = 'file:'
      }

      if (false == protocol.slice(0, -1) in get.protocols) {
        onfatal(new TypeError(`Unsupported protocol type for file '${filename}'`))
      }

      const stream = await pify(get)(filename)
      const buffer = await pify(collect)(stream)
      const secret = JSON.parse(buffer)
      const doc = secrets.derive(secret, argv)
      await save(doc)
    }
  } else if (argv.export) {
    const doc = await secrets.load(argv)
    if (doc.public) {
      console.error(doc.public.discoveryKey.toString('hex'))
    } else if (doc.secret) {
      console.error(doc.secret.discoveryKey.toString('hex'))
    }
    if (argv.public) {
      if (null == doc.public) {
        onfatal(new Error("Missing public secret."))
      }
      if (argv.out) {
        await pify(fs.writeFile)(resolve(argv.out), JSON.stringify(doc.public))
      } else {
        console.log(JSON.stringify(doc.public))
      }
    } else {
      if (argv.out) {
        await pify(fs.writeFile)(resolve(argv.out), JSON.stringify(doc.secret))
      } else {
        console.log(JSON.stringify(doc))
      }
    }
  } else {
    const doc = secrets.encrypt(argv)
    await save(doc)
    console.log(JSON.stringify(doc))
  }

  async function save(doc) {
    // sanity check
    try {
      if (doc.public) { secrets.decrypt(doc.public, argv) }
      if (doc.secrets) { secrets.decrypt(doc.secret, argv) }
    } catch (err) {
      debug(err)
      onfatal(new Error("An unknown error has occurred during encryption."))
    }

    const root = argv.out || argv.root
    const key = crypto.blake2b(Buffer.from(argv.key)).toString('hex')
    const out = {}

    try { await pify(fs.access)(root) }
    catch (err) { await pify(mkdirp)(root) }

    const stat = await pify(fs.stat)(root)

    if (false == stat.isDirectory()) {
      onfatal(new Error(`${root} is not a directory.`))
    }

    out.secret = resolve(root, key)
    out.public = out.secret + '.pub'

    if (doc.public) {
      warn("Writing public file '%s", out.public)
      await pify(fs.writeFile)(out.public, Buffer.from(JSON.stringify(doc.public)))
    } else try {
      await pify(fs.access)(out.public)
      warn("Removing public file '%s'", out.public)
      await pify(fs.unlink)(out.public)
    } catch (err) {}

    if (doc.secret) {
      warn("Writing secret file '%s", out.secret)
      await pify(fs.writeFile)(out.secret, Buffer.from(JSON.stringify(doc.secret)))
    } else try {
      await pify(fs.access)(out.secret)
      warn("Removing secret file '%s'", out.secret)
      await pify(fs.unlink)(out.secret)
    } catch (err) {}
  }
}()

/**
 * Handles fatal errors.
 * @private
 * @param {Error} err
 */
function onfatal(err) {
  debug(err)
  error("fatal:", err.message)
  process.exit(1)
}
