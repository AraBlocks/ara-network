#!/usr/bin/env node

const { info, warn, error } = require('ara-console')
const { resolve, basename } = require('path')
const inquirer = require('inquirer')
const collect = require('collect-stream')
const program = require('yargs')
const secrets = require('../secrets')
const crypto = require('ara-crypto')
const mkdirp = require('mkdirp')
const debug = require('debug')('ara:network:secrets')
const pify = require('pify')
const get = require('get-uri')
const url = require('url')
const rc = require('../rc')()
const fs = require('fs')

const $0 = basename(process.argv[1] || 'ara-network-secrets')

const { argv } = program
  .wrap(100)
  .alias('help', 'h')
  .alias('version', 'V')
  .usage("usage: $0 [-hDV] [options] [did]")
  .option('debug', {
    type: 'boolean',
    alias: 'D',
    describe: "Enable debug output"
  })
  .option('export', {
    type: 'boolean',
    alias: 'e',
    describe: "Export keystore from network"
  })
  .option('force', {
    type: 'boolean',
    alias: 'f',
    describe: "Remove keystore from network"
  })
  .option('import', {
    type: 'boolean',
    alias: 'i',
    describe: "Import keystore into network"
  })
  .option('key', {
    type: 'string',
    alias: 'k',
    describe: "Encryption key for keystore",
  })
  .option('keystore', {
    type: 'string',
    alias: 'K',
    describe: "Keystore file or object for remote keys",
  })
  .option('out', {
    type: 'string',
    alias: 'o',
    describe: "Output directory",
  })
  .option('public', {
    type: 'boolean',
    alias: 'p',
    describe: "Export public secrets"
  })
  .option('remove', {
    type: 'boolean',
    alias: 'r',
    describe: "Remove keystore from network"
  })
  .option('seed', {
    type: 'string',
    alias: 's',
    describe: "Secrets seed value",
    optional: true,
  })
  .option('root', {
    type: 'string',
    describe: "Root data directory",
    default: rc.network.secrets.root
  })

process.on('unhandledRejection', onfatal)
process.on('uncaughtException', onfatal)

/**
 * Main program entry
 *
 * @public
 */

void async function main() {
  const keys = {}
  process.title = $0

  if (program.argv.debug) {
    require('debug').enable('ara:network*')
  }

  if (argv.root) {
    // Check if the given directory exists, if not, create it.
    try { await pify(fs.access)(argv.root) }
    catch (err) {
      warn("mkdirp: Making network secrets root directory:", argv.root)
      try { await pify(mkdirp)(argv.root) }
      catch (err) { return onfatal(err) }
    }

    const stat = await pify(fs.stat)(argv.root)

    if (false == stat.isDirectory()) {
      return onfatal(new TypeError(`Not a directory: ${argv.root}`))
    }
  }

  if (argv.import) {
    if (null == argv.key) {
      throw new TypeError("Expecting network key for secrets.")
    }

    // `argv._` is any unnamed argument that is passed in
    for (let filename of argv._) {
      let { protocol } = url.parse(filename)
      if (null == protocol) {
        filename = resolve(filename)
        filename = 'file://'+ filename
        protocol = 'file:'
      }

      if (false == protocol.slice(0, -1) in get.protocols) {
        onfatal(new TypeError(`Unsupported protocol type for file '${filename}'`))
      }

      const stream = await pify(get)(filename)
      const buffer = await pify(collect)(stream)
      const secret = JSON.parse(buffer)
      const doc = secrets.derive(secret, argv)
      await save(doc)
    }
  } else if (argv.export) {
    const doc = await secrets.load(argv)
    if (doc.public) {
      console.error(doc.public.discoveryKey.toString('hex'))
    } else if (doc.secret) {
      console.error(doc.secret.discoveryKey.toString('hex'))
    }

    if (argv.public) {
      if (null == doc.public) {
        onfatal(new Error("Missing public secret."))
      }

      if (argv.out) {
        await confirmOverwrite(resolve(argv.out))
        await pify(fs.writeFile)(resolve(argv.out), JSON.stringify(doc.public))
      } else {
        console.log(JSON.stringify(doc.public))
      }

    } else {
      if (argv.out) {
        await confirmOverwrite(resolve(argv.out))
        await pify(fs.writeFile)(resolve(argv.out), JSON.stringify(doc.secret))
      } else {
        if (doc.public || doc.secret) {
          console.log(JSON.stringify(doc))
        } else {
          onfatal(new Error(`Unable to find secrets for '${argv.key}'`))
        }
      }
    }
  } else if (argv.remove) {
    await remove()
  } else {
    // if a keystore is given, try to derive it to an object,
    // then prompt the user for a passphrase to unlock it, then
    // set those to be the remote key pair
    if (argv.keystore) {
      // see if it is a file path first
      try {
        await pify(fs.access)(argv.keystore)
        argv.keystore = await pify(fs.readFile)(argv.keystore, 'utf8')
      } catch (err) { }
      // see if it is JSON at this point
      try { argv.keystore = JSON.parse(argv.keystore) }
      catch (err) { delete argv.keystore }

      // prune keystore from argv if not an object
      if (null == argv.keystore || 'object' != typeof argv.keystore) {
        delete argv.keystore
      } else {
        const { password } = await inquirer.prompt([{
          type: 'password',
          name: 'password',
          message:
          "Please enter the passphrase associated with the given keystore. \n" +
          "Passphrase:"
        }])

        if (!password) {
          onfatal(new TypeError("Passphrase cannot be empty."))
        }

        try {
          const { secretKey } = crypto.keyPair(crypto.blake2b(Buffer.from(password)))
          const result = crypto.decrypt(argv.keystore, {key: secretKey.slice(0, 16)})
          if (result && result.length) {
            argv.remote = result
          }
        } catch (err) {
          warn(err.message)
          onfatal(new Error("Incorrect passphrase given."))
        }
      }
    }

    // encrypt shared secret into "secrets" document
    const doc = secrets.encrypt(argv)
    await save(doc)

    // output to standard out
    console.log(JSON.stringify(doc))
  }

  /**
   * Save key contents to file
   *
   * @param  {Object} doc Key contents
   */

  async function save(doc) {
    // sanity check
    try {
      if (doc.public) { secrets.decrypt(doc.public, argv) }
      if (doc.secrets) { secrets.decrypt(doc.secret, argv) }
    } catch (err) {
      debug(err)
      onfatal(new Error("An unknown error has occurred during encryption."))
    }

    const root = argv.out || argv.root
    const key = crypto.blake2b(Buffer.from(argv.key), 16).toString('hex')
    const out = {}

    try { await pify(fs.access)(root) }
    catch (err) { await pify(mkdirp)(root) }

    const stat = await pify(fs.stat)(root)

    if (false == stat.isDirectory()) {
      onfatal(new Error(`${root} is not a directory.`))
    }

    out.secret = resolve(root, key)
    out.public = out.secret + '.pub'

    if (doc.public) {
      await confirmOverwrite(resolve(out.public))
      warn("Writing public file '%s", out.public)
      await pify(fs.writeFile)(out.public, Buffer.from(JSON.stringify(doc.public)))
    } else try {
      await pify(fs.access)(out.public)
      warn("Removing public file '%s'", out.public)
      await pify(fs.unlink)(out.public)
    } catch (err) {}

    if (doc.secret) {
      await confirmOverwrite(resolve(out.secret))
      warn("Writing secret file '%s", out.secret)
      await pify(fs.writeFile)(out.secret, Buffer.from(JSON.stringify(doc.secret)))
  } else try {
    await pify(fs.access)(out.secret)
    warn("Removing secret file '%s'", out.secret)
      await pify(fs.unlink)(out.secret)
    } catch (err) {}
  }

  /**
   * Delete key specified through CLI
   */

  async function remove() {
    const root = argv.out || argv.root
    const key = crypto.blake2b(Buffer.from(argv.key), 16).toString('hex')
    const out = {}
    out.secret = resolve(root, key)
    out.public = out.secret + '.pub'

    try {
      await pify(fs.access)(out.public)
      warn("Removing public file '%s'", out.public)
      await pify(fs.unlink)(out.public)
    } catch (err) {}

    try {
      await pify(fs.access)(out.secret)
      warn("Removing secret file '%s'", out.secret)
      await pify(fs.unlink)(out.secret)
    } catch (err) {}
  }
}()

/**
 * Confirm overwriting output file
 *
 * @param  {String} filename Filename that will be overwritten
 *
 * @return {Boolean}
 */

async function confirmOverwrite(filename) {
  if (argv.force) { return true }
  try { await pify(fs.access)(filename) }
  catch (err) { return true }
  const { confirm } = await inquirer.prompt([{
    type: 'confirm',
    name: 'confirm',
    default: false,
    message:
    `${filename} already exists.\n` +
    "Overwrite?"
  }])

  if (false == confirm) {
    onfatal(new Error(`Not removing file '${filename}'`))
  }
}

/**
 * Handles fatal errors.
 *
 * @private
 *
 * @param {Error} err
 */

function onfatal(err) {
  debug(err)
  error("fatal:", err.message)
  process.exit(1)
}
